{
  "filename": "线程池的动态更新.md",
  "__html": "<h2 id=\"%E5%89%8D%E8%A8%80\">前言 <a class=\"header-anchor\" href=\"#%E5%89%8D%E8%A8%80\">#</a></h2>\n<p>线程池（Thread Pool）是一种基于 <strong>池化思想管理线程的工具</strong>。使用线程池可以 <strong>减少创建销毁线程的开销</strong>，避免线程过多导致系统资源耗尽</p>\n<p>目前线程池被广泛应用于业务系统，但是业界内对线程池 <strong>初始化参数并没有很好的标准</strong>。线上环境的线程池因为业务特殊性遇到一些痛点，进而引发了小编对于线程池使用的一些思考</p>\n<h2 id=\"%E7%BA%BF%E4%B8%8A%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%83%BD%E5%90%88%E7%90%86%E8%AF%84%E4%BC%B0\">线上配置不能合理评估 <a class=\"header-anchor\" href=\"#%E7%BA%BF%E4%B8%8A%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%83%BD%E5%90%88%E7%90%86%E8%AF%84%E4%BC%B0\">#</a></h2>\n<p>最大的痛点就是无法正确评估线程池关键参数的配置。比如核心线程数、最大线程数、阻塞队列大小等，一旦上线参数就无法更改</p>\n<p>设想一下，当你兴致勃勃的对业务使用了线程池之后，有没有考虑过这几种场景</p>\n<ol>\n<li>核心线程过小，阻塞队列过小，最大线程过小，<strong>导致接口频繁抛出拒绝策略异常</strong></li>\n<li>核心线程过小，阻塞队列过小，最大线程过大，<strong>导致线程调度开销增大，处理速度下降</strong>。如果遇到周期性突发流量，更是如此</li>\n<li>核心线程过小，阻塞队列过大，导致任务堆积，<strong>接口响应或者程序执行时间拉长</strong></li>\n<li>核心线程过大，<strong>导致线程池内空闲线程过多，过多的占用系统资源，造成资源浪费</strong></li>\n</ol>\n<blockquote>\n<p>上面的某些场景，受其它参数的影响，并不是绝对成立</p>\n</blockquote>\n<p>曾经这么考虑过，提前计算好线程池的各项参数不就 OK 了么，要什么动态？</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/84789754389758432.png\" alt=\"\"></p>\n<p>这里说一下，大多数的业务场景下，<strong>线程池参数最好的情况是大差不差</strong>。什么意思呢，就是当业务运行中时，线程池有少量的资源浪费或者触发少量的拒绝任务</p>\n<p>但是，<strong>有些业务的波动并不是可以预测的</strong>。比如说有一家开饭店的老板，周一到周四客人并不多，所以平常也没备那么多的菜，凑巧来了一个旅游团来吃饭，饭店存量也就捉襟见肘了，而这种突发情况并不可预估</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725174444009.png\" alt=\"\"></p>\n<p>如果业务系统遇到上述情况，可能需要根据突来的流量重新预估线程池的参数，将系统重新进行发布并查看当前线程池的参数是否合理，如果不合理极有可能还要再来一遍流程</p>\n<p>而动态线程池要做的就是将 <strong>参数的修改与系统的发布进行隔离</strong>，流程图如下</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210731221234040.png\" alt=\"\"></p>\n<h2 id=\"%E6%B2%A1%E6%9C%89%E5%90%88%E7%90%86%E7%9A%84%E7%9B%91%E6%8E%A7\">没有合理的监控 <a class=\"header-anchor\" href=\"#%E6%B2%A1%E6%9C%89%E5%90%88%E7%90%86%E7%9A%84%E7%9B%91%E6%8E%A7\">#</a></h2>\n<p>上面提到出现的参数不合理场景如何发现呢，那就是 <strong>线程池运行时监控</strong></p>\n<p>如果可以知道一部分线程池运行时指标，可以极大程度上的预防上述问题，这里举一些例子</p>\n<ol>\n<li>监控业务线程池的 <strong>当前负载以及峰值负载</strong></li>\n<li>监控线程池在不同时间段 <strong>核心线程、最大线程、活跃线程数量指标</strong></li>\n<li>监控线程 <strong>池阻塞队列相关指标</strong>，判断是否有任务积压的风险</li>\n<li>监控线程任务在 <strong>运行时抛出的异常数量</strong>，诊断投递的任务是否“健康”</li>\n<li>监控线程池执行 <strong>拒绝策略执行的次数</strong>，确定线程池参数是否合理</li>\n</ol>\n<p>如果监控搭配上合理的报警信息，可以极大程度上避免开发对于线上业务的后知后觉，有效预防一些问题以及提高业务 BUG 的修复速度</p>\n<p>上述关于线程池动态参数、监控以及预警等思考，源自于美团技术博客 <a href=\"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html\" title=\"《Java线程池实现原理及其在美团业务中的实践》\">《Java 线程池实现原理及其在美团业务中的实践》</a></p>\n<h2 id=\"%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0\">如何动态更新参数 <a class=\"header-anchor\" href=\"#%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0\">#</a></h2>\n<p>动态设置线程池参数涉及到两个问题，都有哪些参数可以动态更新？使用什么方式动态更新？</p>\n<p>这里先列举下原声线程池 API 支持修改的参数集合，然后梳理看看支持修改后有什么好处</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210722100831053.png\" alt=\"\"></p>\n<p><strong>CorePoolSize（核心线程数量）</strong></p>\n<p>线程池中空闲时存在最小的线程数量。可以通过 <code>#setCorePoolSize</code> 修改线程池核心线程数量，流程图如下</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725183823342.png\" alt=\"\"></p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725142615228.png\" alt=\"\"></p>\n<p>相对于其它几个动态参数，核心线程数的动态设置流程还算复杂一些</p>\n<ol>\n<li>判断设置的 <code>new corePoolSize</code> 必须大于 0，否则抛出异常</li>\n<li>直接替换线程池的 <code>corePoolSize</code> 为 <code>new corePoolSize</code></li>\n<li>判断线程池的工作线程是否大于 <code>new corePoolSize</code>，条件如果成立则执行中断多余空闲的线程</li>\n<li>如果上述条件不成立，判断 <code>corePoolSize</code> 是否小于 <code>new corePoolSize</code>，如果小于说明需要创建新的核心线程</li>\n</ol>\n<p>关于第四步，有一个小知识点，线程池作者为了保证线程资源不浪费而做出的优化</p>\n<p>执行第四步时通过注释得知，并不知道需要创建多少线程，<strong>而为了保证线程资源不会被浪费</strong>，这里会依据 <code>workQueue#size</code> 和 delata 来计算出需要创建的线程数量 k</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725142615381.png\" alt=\"\"></p>\n<p><code>Math#min</code> 会返回两个值中小的那个，小编想到了三种情况，我们这里来假设下</p>\n<ol>\n<li>假设 <code>workQueue#size == 0</code>，那么 k 也等于零，证明并没有阻塞住的任务需要执行，<code>k-- &gt; 0</code> 表达式并不成立，就不会执行 <code>#addWorker</code></li>\n<li>假设 <code>workQueue#size &gt; 0 &amp;&amp; &lt; delta</code>，此时任务队列里有待执行任务。<code>k-- &gt; 0</code> 表达式成立，一般情况会创建 <code>workQueue#size</code> 个新核心线程，二般情况下是线程池里其它线程把 <code>workQueue</code> 的任务清了，就会跳出创建流程</li>\n<li>假设 <code>workQueue#size &gt; 0 &amp;&amp; &gt; delta</code>，这种情况最多会创建 delata 个新核心线程</li>\n</ol>\n<p>这里也给我们一个启发，<strong>写代码不能只顾着自扫门前雪</strong>，而是要从全局的角度去思考代码有没有可以提升的空间</p>\n<p>小编问了下自己，<strong>核心线程在没任务时是不会被回收的</strong>，如果核心线程数设置的太大，过去了峰值期岂不是属于资源浪费，难道还要自己再把数量调整回来么</p>\n<p>我们可以在创建线程池时通过设置一个参数控制。<code>allowsCoreThreadTimeOut</code> 默认为 False，即核心线程即使在空闲时也保持活动状态。如果为 True，核心线程使用 <code>keepAliveTime</code> 来超时等待工作</p>\n<p><strong>核心线程动态的坑</strong></p>\n<p>有一个很重要的点需要注意，<strong>核心线程数设置时可能失效</strong>。比如说，最大线程数为 5，当前线程池内活跃线程数为 5，此时设置核心线程数为 10 的话，一定是不生效的，Why？</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210731142501203.png\" alt=\"\"></p>\n<p>先假设线程池的运行时状态如下，核心线程为 3，最大线程是 5，线程池内活跃线程为 5，此时调用 <code>#setCorePoolSize</code> 动态设置核心线程数为 10</p>\n<p>执行完上述操作之后，调用 <code>#execute</code> 向线程池发起任务执行，内部处理逻辑如下</p>\n<ol>\n<li>判断当前线程池核心数为 10，当前工作线程为 5，那么会 <strong>发起 <code>#addWorker</code> 添加线程</strong></li>\n<li><code>#addWorker</code> 会对 <strong>工作线程数量 + 1</strong>，此时真正意义上并不算此 Worker 添加到线程池</li>\n<li>接下来会创建线程的包装类 Worker 并执行 Start，因为 Worker 本身持有线程对象，<strong>Start 也是操作线程去执行任务</strong></li>\n<li>获取任务 <code>#getTask</code> 有一步操作是动态修改核心线程数不生效的原因，那就是在真正获取队列中任务执行时会先 <strong>判断当前的工作线程数量是否大于最大线程</strong></li>\n<li>因为上面对工作线程有 +1 的操作，所以池内工作线程数是 6，条件判断表达式成立，接下来会对 <strong>工作线程数量执行 -1 操作</strong>，<strong>并销毁此 Worker</strong></li>\n</ol>\n<p>这里贴一下线程池获取队列任务 <code>#getTask</code> 的代码片段，大家粗略看一下</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210729082950488.png\" alt=\"\"></p>\n<p>既然已经知道问题出在哪里，应该如何去解决动态设置失效呢</p>\n<p>其实办法很简单，<strong>那就是在设置核心线程的时候，同时设置最大线程数就可以</strong>。只要工作线程不大于最大线程数，那么动态设置就是有效的</p>\n<p>本小节参考自 <a href=\"https://cloud.tencent.com/developer/article/1615007\" title=\"如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答\">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答</a></p>\n<p><strong>MaximumPoolSize（最大线程数）</strong></p>\n<p>表示线程池中可以创建的最大线程数。通过 <code>#setMaximumPoolSize</code> 重新设置最大线程数，修改逻辑如下</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725142619483.png\" alt=\"\"></p>\n<p>线程池中设置最大线程数的源码比较简单，并不包含复杂的逻辑，流程如下</p>\n<ol>\n<li>判断 <code>new maximumPoolSize</code> 参数是否正确，不满足条件则抛出异常终止流程</li>\n<li>设置 <code>new maximumPoolSize</code> 替换线程池最大线程数</li>\n<li>如果线程池工作线程大于 <code>new maximumPoolSize</code>，则对多余 Worker 发起中断流程</li>\n</ol>\n<p><strong>ThreadFactory（线程工厂）</strong></p>\n<p>线程工厂的功能是为线程池创建线程，线程创建时可以设置自定义线程 <strong>名称前缀（重要）</strong>、设置是否 daemon 线程、线程 priority 优先级以及线程未捕获异常的处理方式</p>\n<p>虽然线程工厂可以在运行后重新设置参数，<strong>但是并不建议这么做</strong>。因为已经运行的线程不会因为被销毁，如果之前运行的线程不被销毁，一个线程池中极有可能出现两种不同语义的线程</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725142648283.png\" alt=\"\"></p>\n<p>示例代码中创建了一个线程池，并指定了线程工厂前缀名称 before。对线程池运行任务使其内部拥有 before 工厂创建线程</p>\n<p>之后新创建一个 after 线程工厂，进行替换线程池内部工厂，并运行任务创建最大线程数，我们可以查看下日志</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210728085957701.png\" alt=\"\"></p>\n<p>不出所料两个线程工厂创建的线程各自为战，并且如果没有特殊操作，这种情况会一直持续下去 。所以综上所述，并不建议业务中对线程工厂修改，不然坑的都是自己人～</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/IMG_3204.GIF\" alt=\"\"></p>\n<p><strong>其它参数</strong></p>\n<p>剩余两个动态调整的参数较为简单，就不一一举例说明了，大家看下源码即可</p>\n<ul>\n<li><code>KeepAliveTime</code></li>\n<li><code>RejectedExecutionHandler</code></li>\n</ul>\n<p>还有一个很重要的参数需要动态更新，那就是 <strong>阻塞队列的大小</strong>。可能有的小伙伴就会问了，为什么不直接替换阻塞队列呢？</p>\n<p>其实可以实现直接替换阻塞队列，但是如果直接替换会引发出很多的问题，举个最直接的例子，<strong>原队列中的堆积任务不好处理</strong>，修改容量就能解决问题的事情，没必要复杂化。所以在做动态时，考虑的只是阻塞队列的大小而不是替换</p>\n<p>这里以 <code>LinkedBlockingQueue</code> 为例，队列在源码中并没有提供修改队列大小的方法，因为代表队列大小的变量 <code>capacity</code> 被 final 关键字修饰</p>\n<p>大家可以考虑下，基于这种 final 修饰的情况，应该如何去扩展阻塞队列的容量修改</p>\n<h2 id=\"%E5%8A%A8%E6%80%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\">动态的阻塞队列 <a class=\"header-anchor\" href=\"#%E5%8A%A8%E6%80%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\">#</a></h2>\n<p>线程池中是以 <strong>生产者消费者模式</strong>，通过一个阻塞队列来缓存任务，<strong>工作线程从阻塞队列中获取任务</strong>。工作队列的接口是阻塞队列（BlockingQueue），在队列为空时，获取元素的线程会 <strong>等待队列变为非空</strong>，当队列满时，存储元素的线程会 <strong>等待队列可用</strong></p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/725a3db5114d95675f2098c12dc331c3316963.png\" alt=\"图片来源美团技术博客\"></p>\n<p>阻塞队列动态设置队列大小，有很多种操作方式。可以按照原逻辑不变加一些扩展，也可以在特定方法上进行重写，<strong>实现方式并不固定</strong>。下面说几种可以实现动态阻塞队列功能的方案</p>\n<blockquote>\n<ol>\n<li>复制阻塞队列源代码实现，添加 #set 方法使 capacity 可变</li>\n<li>继承阻塞队列，并在原基础上重写核心方法</li>\n<li>继承阻塞队列，反射动态修改 capacity</li>\n</ol>\n</blockquote>\n<p>如果不需要重写原阻塞队列获得额外的功能，<strong>小编更倾向于第一种</strong>，代码上会更简洁一些，并且稳定。下面以 <code>LBQ</code> 为例</p>\n<h3 id=\"%E5%A4%8D%E5%88%B6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\">复制阻塞队列 <a class=\"header-anchor\" href=\"#%E5%A4%8D%E5%88%B6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\">#</a></h3>\n<p>这一种方式简单粗暴，直接把 <code>LinkedBlockingQueue</code> 代码复制出来一份，改个新名字 <code>ResizableCapacityLinkedBlockIngQueue</code>，然后把 <code>capacity</code> 所修饰的 <code>final</code> 关键字去掉，再加上一个 <code>#setCapacity</code> 方法</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725142618847.png\" alt=\"\"></p>\n<h3 id=\"%E9%87%8D%E5%86%99%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95\">重写核心方法 <a class=\"header-anchor\" href=\"#%E9%87%8D%E5%86%99%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95\">#</a></h3>\n<p>网上大多数博主使用的都是上述复制阻塞队列的方式，后来和两位大佬讨论阻塞队列的动态，然后从 GitHub 上发现了一位国外程序员的版本，通过信号量的方式控制阻塞队列的大小，<a href=\"https://sourl.cn/7Uvw88\" title=\"《GitHub LinkedBQ 信号量实现》\">《GitHub LinkedBQ 信号量实现》</a></p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725142619846.png\" alt=\"\"></p>\n<p>队列中包含阻塞 <strong>队列的大小以及自实现的信号量</strong>。每次进行调整阻塞队列大小的同时也对信号量进行增减</p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-202107251426193984.png\" alt=\"\"></p>\n<h3 id=\"%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9-capacity\">反射修改 Capacity <a class=\"header-anchor\" href=\"#%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9-capacity\">#</a></h3>\n<p>通过反射的方式同样可以达到阻塞队列动态修改的功能。在修改之前，有考虑过这种方式 <strong>会不会存在线程不安全的问题</strong>，对此使用 Jmeter 线程组和修改 capacity 交替操作，进行了几轮测试，测试的结论是 <strong>不存在线程安全问题</strong></p>\n<p><img src=\"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20210725144444283.png\" alt=\"\"></p>\n<p>对于使用反射修改阻塞队列大小，<strong>小编是不推荐的</strong>。首先这种硬编码的方式并不优雅，其次并不能百分百保证能兼容后续 JDK 版本</p>\n<p>综合考虑，虽然反射修改 capacity 可以达到理想中的效果，但是不建议这么做</p>\n",
  "link": "/zh-cn/blog/线程池的动态更新.html",
  "meta": {}
}